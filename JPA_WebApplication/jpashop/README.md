## JPA WEB Application 
 해당 문서는 김영한 - 실전 스프링 부트와 JPA 활용 웹 애플리케이션 강의를 듣고 정리한 내용입니다.

### JPA DB 초기화 설정
 * application.properties(config 파일)에서 ```spring.jpa.hibernate.ddl-auto```초기화 전략 설정
     - none : 데이터베이스 구조를 변경하지 않는다. (Default)
     - create-drop : SessionFactory 시작할때 drop 후 DDL 생성 하며 종료 시 all drop 한다. 
     - create : SessionFactory 가 시작 될 떄 데이터베이스 drop 를 실행하고 생성된 DDL 실행
     - update : 변경된 스키마만을 적용한다.
     - validate : 변경된 스키마가 있다면 변경점을 출력하고 애플리케이션을 종료한다. (확인만 하며 변경사항 적용하지 않음)

### JPA Logger
 - jpa ```show_sql``` 옵션은 System.out 에 하이버네이트 실행 SQL을 남긴다.
 - ```org.hibernate.SQL``` 옵션은 logger를 통하여 하이버네이트 실행 SQL을 남긴다.

### 연관관계 매핑 시 유의사항
 - 외래키가 있는곳을 연관관계의 주인으로 정하여 매핑하는것이 좋다
 - 모든 연관관계는 지연 로딩으로 설정하도록 하는것이 좋다. 
    <br/> => 즉시 로딩 시 관련된 쿼리를 전부 다 조회하기 때문에 성능적으로 좋지 않다.
 - 연관된 엔티티를 함께 DB에서 조회해야 한다면, fetch join 또는 엔티티 그래프 기능을 사용한다.
 - @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩 설정 필요


### 엔티티 클래스 개발 시 유의사항
 - Getter만 클래스에 적용하는것이 좋다 (Setter 지양) => 생성자나 별도의 메소드로 정의
 - 값타입은 생성자로 변경 불가능한 불변객체로 생성, 기본 생성자는 접근 제어자를 protected 로 선언
   <br/> => JPA 구현 라이브러리가 객체를 생성할 떄 리플랙션 같은 기술을 사용할 수 있도록 지원 해야하기 때문
 - 컬렉션은 필드에서 초기화 => null 문제 해결

``` 애플리케이션 아키텍처
                     [ Controller => Service => Repository ] => DB
                                    => Domain
```

#### @PersistenceContext 
 - EntityManager 주입, 필드 선언
 - @PersistenceContext private EntityManager em;

### @PersistenceUnit
 - EntityManagerFactory 주입, 클래스 선언

### @Transactional
 * 트랜잭션, 영속성 컨텍스트
   - 속성 readOnly = true : 데이터의 변경이 없는 읽기 전용 메서드에 사용, 성능 향상
   - 데이터베이스 드라이버가 지원하면 DB에서 성능 향상
   - 기본은 readOnly = false, 클래스에 적용하면 전체 메소드에 동시적용, 전체 적용해도 메소드에 재정의하면 정의한 메소드에는 적용한 속성 적용

### 생성자 주입
 - 생성자 주입 방식을 권장
 - 변경 불가능한 안전한 객체 생성 가능
 - 생성한 하나면, @Autowired 를 생략할 수 있다.
 - final 키워드를 추가하면 컴파일 시점에 의존성 주입한 객체를 설정하지 않는 오류 체크 가능

### JPA 테스트 기술
 - @RunWith(SpringRunner.class) : 스프링과의 테스트 통합
 - @SpringBootTes : 스프링 부트를 띄우고 테스트 (@Autowired 환경 구성)
 - @Transactional : 각각의 테스트를 실행할 때 마다 트랜잭션을 실행하고 테스트 종료 시 트랜잭션 롤벡

### 비즈니스 로직 패턴
 - 도메인 모델 패턴 : 엔티티가 비즈니스 로직을 가지고 객체지향의 특성을 활용, 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할
 - 트랜잭션 스크립트 패턴 : 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 비즈니스 로직 처리

### JPA 동적 쿼리 해결 방안
 1. JPQL 문자열 조립
    - JQPL 쿼리문을 조건마다 생각하여 String 문자열을 붙혀 문자열을 조립하여 사용
 2. JPA Criteria
    - JQPL을 조립해주는것을 도와주지만, 유지보수성이 낮으며 추천하지 않는 방식
 3. QueryDSL 
    - 동적 쿼리를 처리하기 가장 좋은 라이브러리

### Valid
 - @NotEmpty : null 및 "" 밸리데이션
 - @NotNull : null 값만 밸리데이션

``` API 생성 시 유의사항
 엔티티는 핵심 비즈니스 로직만 가지고 있고, 화면을 위한 로직은 없어야한다.
 Entity를 사용하여 Response를 반환하지 말고 DTO를 통한 데이터 바인딩을 통해 필요한 데이터만 반환
```

## 변경 감지와 병합(merge)
 ### 준영속 엔티티
  - 영속성 컨텍스트가 더는 관리하지 않는 엔티티
  - 수정을 시도하는 Entity 객체는 이미 DB에 저장되어 있어서 식별자가 존재한다.
  - 이렇게 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있다.

 ### 준영속 엔티티를 수정하는 2가지 방법
  #### 1. 변경 감지 기능 사용 (권장)
    - 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법
    - 트랜잭션 안에서 엔티티를 다시 조회, 변경할 값 선택 (Dirty Checking)
  #### 2. 병합 사용
    - merge() 실행
    - 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티 조회
        - 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차캐시에 저장
    - 조회한 영속 엔티티에 엔티티의 값을 채워 넣는다 
    - 값을 채워넣은 영속 엔티티 반환

  #### 주의사항
  - 변경 감지 기능을 사용하면 원하는 속성만 선택하여 변경 가능, 병합 사용 시 모든 속성이 변경되어 병합 시 값이 없으면 null로 업데이트 할 위험이 있따